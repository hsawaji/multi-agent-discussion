# システムリアーキテクチャ技術選定 意思決定書

## 1. 結論

### 言語・技術スタック
**Go言語 + クリーンアーキテクチャ**を推奨します。

フレームワークは軽量なもの（Echo, Gin, Chi等）を採用し、フレームワーク依存を最小限に抑えた設計とします。

### 開発手法・理論
**ドメイン駆動設計（DDD）** と **モジュラーモノリス** アーキテクチャの組み合わせを推奨します。

---

## 2. 結論に対する簡単な説明

Go言語は静的型付けによる堅牢性、シンプルな言語仕様による学習コストの低さ、優れた並行処理性能を兼ね備えており、大規模サービスのリアーキテクチャに適しています。クリーンアーキテクチャとDDDを組み合わせることで、ビジネスロジックをフレームワークやインフラから分離し、長期的な保守性を確保できます。モジュラーモノリスは段階的な移行を可能にし、運用負荷を抑えながら将来のマイクロサービス化への道筋も残します。

---

## 3. 背景に記載がない前提

本検討では以下の前提を置いています：

1. **チーム構成**: 現在のチームはPHP経験者が中心であり、新言語への移行には学習期間が必要
2. **移行期間**: 段階的な移行を想定し、新旧システムの並行稼働期間がある
3. **インフラ**: クラウド環境（AWS/GCP等）での運用を想定
4. **トラフィック特性**: 健康管理サービスとして朝・昼・夜の食事記録時にアクセスが集中すると想定
5. **データベース**: 既存のRDBMS（MySQL/PostgreSQL等）を継続利用
6. **フロントエンド**: モバイルアプリが主要クライアントであり、APIサーバーとしての役割が中心
7. **予算・期間**: 十分なリソースが確保されており、品質を優先できる
8. **採用市場**: 新技術の採用においてエンジニア採用への影響も考慮が必要

---

## 4. 検討の詳細

### 4.1 言語選定の検討

#### 候補言語の比較

| 評価項目 | PHP (Laravel) | Go | Kotlin (Spring) | TypeScript (NestJS) |
|---------|--------------|-----|-----------------|-------------------|
| 型安全性 | △ (PHP8で改善) | ◎ | ◎ | ○ |
| パフォーマンス | △ | ◎ | ○ | △ |
| 学習コスト | ◎ (既存知見) | ○ | △ | ○ |
| 保守性 | △ | ◎ | ◎ | ○ |
| 採用市場 | ○ | ◎ | ○ | ◎ |
| エコシステム | ◎ | ○ | ◎ | ○ |

#### 各言語の詳細評価

**PHP (Laravel)**
- メリット: 既存チームの知見を活かせる、移行コストが低い、豊富なライブラリ
- デメリット: 型安全性が他言語に劣る、大規模開発での品質担保が難しい
- 評価: リアーキテクチャの目的である「複雑さの解消」を達成するには、言語レベルでの制約が弱い

**Go**
- メリット: シンプルな言語仕様、高パフォーマンス、強力な並行処理、コンパイル時のエラー検出
- デメリット: ジェネリクスの導入が最近（Go 1.18）、フレームワークのエコシステムがPHPより小さい
- 評価: 言語のシンプルさが保守性に直結。大規模Webサービスでの実績多数（YouTube, Uber, Twitch等）

**Kotlin (Spring Boot)**
- メリット: 強力な型システム、Null安全、Javaエコシステムの活用
- デメリット: JVM起動のオーバーヘッド、Spring Bootの学習コスト
- 評価: エンタープライズ向けには優秀だが、PHPからの移行としては学習コストが高い

**TypeScript (NestJS)**
- メリット: フロントエンドとの言語統一、型安全、デコレータベースの宣言的記述
- デメリット: Node.jsのシングルスレッド特性、実行時パフォーマンス
- 評価: フルスタック開発には有利だが、バックエンド専用としては他選択肢が優位

#### 結論: Go言語を推奨

Go言語を推奨する主な理由：

1. **シンプルな言語仕様**: 仕様が小さく、チーム全体で一貫したコードスタイルを維持しやすい
2. **型安全性**: コンパイル時に多くのバグを検出可能
3. **パフォーマンス**: 会員900万人規模のサービスにおいて、サーバーコスト削減に寄与
4. **学習曲線**: 言語自体の学習は比較的容易で、2-3ヶ月で生産的になれる
5. **採用市場**: 近年Go言語エンジニアの市場は拡大傾向

---

### 4.2 アーキテクチャ・設計手法の検討

#### アーキテクチャパターンの比較

| パターン | 保守性 | 移行容易性 | 運用複雑性 | スケーラビリティ |
|---------|--------|-----------|-----------|----------------|
| モノリス | △ | ◎ | ◎ | △ |
| モジュラーモノリス | ◎ | ○ | ○ | ○ |
| マイクロサービス | ○ | △ | △ | ◎ |

#### 各パターンの評価

**従来型モノリス**
- 現状の課題がまさにこのパターンに起因している
- 単純な継続は選択肢から除外

**マイクロサービス**
- メリット: 独立したデプロイ、技術選択の自由度、障害の局所化
- デメリット: 分散システムの複雑性、運用負荷の増大、データ整合性の課題
- 評価: 10年間のモノリスから一気にマイクロサービスへの移行はリスクが高い

**モジュラーモノリス**
- メリット: モノリスの運用容易性とモジュール分割の保守性を両立、段階的な移行が可能
- デメリット: モジュール境界の規律が必要、将来的な分割には追加作業が必要
- 評価: 現実的な移行パスとして最適

#### 結論: モジュラーモノリスを推奨

---

### 4.3 設計手法の検討

#### ドメイン駆動設計（DDD）の採用

健康管理サービスという複雑なビジネスドメインを扱うため、DDDの採用を推奨します。

**戦略的設計**
- 境界づけられたコンテキストの特定（例: ユーザー管理、食事記録、運動記録、分析・レポート）
- ユビキタス言語の定義と共有
- コンテキストマップによる関係性の可視化

**戦術的設計**
- エンティティ、値オブジェクト、集約の適切な設計
- リポジトリパターンによるデータアクセスの抽象化
- ドメインサービス、アプリケーションサービスの分離

#### クリーンアーキテクチャの採用

レイヤー構成：
```
├── domain/          # ドメイン層（エンティティ、値オブジェクト、リポジトリインターフェース）
├── usecase/         # ユースケース層（アプリケーションロジック）
├── interface/       # インターフェース層（コントローラ、プレゼンター）
└── infrastructure/  # インフラ層（DB実装、外部API、フレームワーク）
```

**依存関係のルール**
- 内側の層は外側の層に依存しない
- インターフェース（抽象）に依存し、実装に依存しない
- フレームワーク・ライブラリはインフラ層に閉じ込める

---

### 4.4 その他の推奨プラクティス

1. **テスト戦略**
   - ユニットテスト: ドメインロジックを中心に高カバレッジを目指す
   - 統合テスト: ユースケース単位でのテスト
   - E2Eテスト: 主要なユーザーシナリオに限定

2. **CI/CD**
   - プルリクエスト時の自動テスト実行
   - 静的解析ツール（golangci-lint等）の導入
   - 自動デプロイパイプラインの構築

3. **ドキュメンテーション**
   - ADR（Architecture Decision Records）の運用
   - APIドキュメントの自動生成（OpenAPI/Swagger）
   - コンテキストマップの継続的な更新

4. **段階的移行戦略**
   - Strangler Figパターンによる段階的な置き換え
   - 新機能は新システムで開発
   - リスクの低い機能から順次移行

---

## 最終結論

| 項目 | 選定結果 |
|------|---------|
| 言語 | Go |
| フレームワーク | Echo または Chi（軽量なもの） |
| アーキテクチャ | モジュラーモノリス |
| 設計手法 | ドメイン駆動設計 + クリーンアーキテクチャ |
| 移行戦略 | Strangler Figパターン |

この選定により、10年後も保守可能なシステムの構築を目指します。
