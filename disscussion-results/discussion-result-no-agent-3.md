# システムリアーキテクチャ技術選定 結果

## 1. 結論

### 言語・技術スタック
**推奨: Go または Kotlin (Spring Boot)**

- 第一候補: **Go** - シンプルさと高パフォーマンスを重視する場合
- 第二候補: **Kotlin + Spring Boot** - エンタープライズ機能の充実を重視する場合

### 開発手法・理論
- **ドメイン駆動設計 (DDD)** をベースとした設計
- **クリーンアーキテクチャ** による依存関係の管理
- **モジュラーモノリス** からの段階的なマイクロサービス化

---

## 2. 結論に対する簡単な説明

10年以上運用されたPHP/CakePHPからの移行では、静的型付け言語への転換が保守性向上の鍵となります。GoはシンプルでパフォーマンスとGoogle等での大規模運用実績があり、Kotlinは型安全性とSpringエコシステムの恩恵を受けられます。DDDとクリーンアーキテクチャを採用することで、ビジネスロジックを明確に分離し、フレームワーク非依存のテスタブルなコードを実現できます。900万会員規模のサービスでは、モジュラーモノリスから始め、必要に応じてマイクロサービス化する段階的アプローチが現実的です。

---

## 3. 背景に記載がない前提

本検討では以下の前提を置いています：

1. **チーム規模**: 複数チームが並行開発を行う中〜大規模チーム（10名以上）を想定
2. **既存システムとの共存**: ビッグバンリプレイスではなく、段階的な移行を行う
3. **インフラ環境**: クラウド環境（AWS/GCP等）での運用を想定
4. **フロントエンド**: バックエンドAPIとして提供し、フロントエンドは別途構築
5. **データベース**: 既存のRDBMS（MySQL/PostgreSQL等）を継続利用
6. **採用市場**: 日本国内での採用を主に想定
7. **予算**: 技術教育・移行にある程度の投資が可能
8. **移行期間**: 1〜2年程度の中長期プロジェクトとして計画

---

## 4. 検討の詳細

### 4.1 言語・技術スタックの比較検討

#### PHP (Laravel) の検討

**メリット:**
- 既存チームのスキルをそのまま活用可能
- 移行コストが最も低い
- Laravelは現代的なPHPフレームワークとして成熟

**デメリット:**
- 動的型付けのため、大規模開発での型安全性に課題
- パフォーマンスは他の選択肢と比較して劣る
- 「PHP = レガシー」というイメージによる採用への影響

**結論:** 短期的なコスト削減には有効だが、「複雑さの解消」という目的に対しては根本的な解決にならない可能性がある。

---

#### TypeScript (NestJS) の検討

**メリット:**
- フロントエンド（React/Vue等）との言語統一が可能
- 型システムによる開発体験の向上
- 非同期I/O処理に優れる

**デメリット:**
- CPU集約型の処理には不向き
- Node.jsのシングルスレッドモデルの制約
- 型システムはコンパイル時のみで、ランタイムでは消える

**結論:** フロントエンドチームとの連携が重要な場合は検討の価値あり。ただし、大規模バックエンドとしての実績はGo/Kotlinほど多くない。

---

#### Go の検討

**メリット:**
- シンプルな言語仕様で学習コストが低い
- 優れたパフォーマンスとメモリ効率
- 強力な並行処理モデル（goroutine）
- Google, Mercari, LINE等での大規模運用実績
- コンパイル速度が速く、開発サイクルが快適
- 静的バイナリのためデプロイが容易

**デメリット:**
- ジェネリクスのサポートが限定的（Go 1.18以降で改善）
- フレームワークの選択肢がJava/PHP程多くない
- エラーハンドリングが冗長になりがち

**結論:** パフォーマンスとシンプルさを重視するなら最有力候補。マイクロサービスアーキテクチャとの相性も良い。

---

#### Kotlin (Spring Boot) の検討

**メリット:**
- 強力な型システムとNull安全性
- Javaの膨大なエコシステムを活用可能
- Spring Bootによるエンタープライズ機能の充実
- コルーチンによる効率的な非同期処理
- Java技術者からの移行が容易

**デメリット:**
- JVM起動時間とメモリ消費
- Spring Bootの学習曲線
- ビルド時間が長くなりがち

**結論:** エンタープライズ機能（認証、トランザクション、バッチ処理等）を重視するなら最有力候補。GraalVMによるネイティブイメージで起動時間問題も改善可能。

---

#### Rust の検討

**メリット:**
- 最高レベルのパフォーマンスとメモリ安全性
- ゼロコスト抽象化

**デメリット:**
- 学習コストが非常に高い
- 開発速度がビジネスアプリケーションには遅い
- 採用市場が限定的

**結論:** Webアプリケーションの一般的なリアーキテクチャには過剰。特定の高パフォーマンスコンポーネントでの部分採用は検討可能。

---

### 4.2 保守性向上のための設計手法の検討

#### ドメイン駆動設計 (DDD)

**採用理由:**
- 10年以上のビジネスロジックを整理・再構築するのに最適
- 「ユビキタス言語」により、開発者とビジネス側の認識を統一
- 境界づけられたコンテキストで、チーム間の責任範囲を明確化
- 健康管理ドメインは複雑なビジネスルールを持つため、DDDの恩恵を受けやすい

**適用方針:**
- 戦略的設計: コンテキストマップの作成、ドメイン境界の定義
- 戦術的設計: エンティティ、値オブジェクト、集約、リポジトリパターンの適用

---

#### クリーンアーキテクチャ / ヘキサゴナルアーキテクチャ

**採用理由:**
- フレームワーク（CakePHP）への依存が複雑さの一因であった可能性
- ビジネスロジックをインフラ層から分離することでテスタビリティ向上
- 将来的な技術変更への耐性

**レイヤー構成例:**
```
├── domain/          # エンティティ、値オブジェクト、ドメインサービス
├── application/     # ユースケース、アプリケーションサービス
├── infrastructure/  # DB、外部API、フレームワーク依存
└── presentation/    # API、コントローラー
```

---

#### モジュラーモノリス vs マイクロサービス

**モジュラーモノリスを出発点として推奨する理由:**
- 900万会員のサービスをいきなりマイクロサービス化するリスクが高い
- 運用の複雑さ（分散トランザクション、サービス間通信）を段階的に学習
- モジュール境界が明確になってからマイクロサービスに分割可能

**段階的アプローチ:**
1. モジュラーモノリスとして新システムを構築
2. 各モジュールの境界を明確に保つ
3. トラフィックやチーム規模に応じて、必要なモジュールをマイクロサービス化

---

### 4.3 移行戦略の検討

**ストラングラーフィグパターンの採用を推奨:**
- 新規機能は新システムで開発
- 既存機能は優先度に応じて段階的に移行
- APIゲートウェイでルーティングを制御

**リスク軽減策:**
- 機能フラグによる段階的リリース
- シャドーテストによる新旧システムの比較
- ロールバック計画の策定
