# 技術選定 意思決定結果

## 1. 結論

### 言語・技術スタック
**Kotlin + Spring Boot** を推奨します。

### 開発手法・理論
**ドメイン駆動設計 (DDD) + クリーンアーキテクチャ** の採用を推奨します。

---

## 2. 結論に対する簡単な説明

Kotlinは静的型付けによる堅牢性と、Javaエコシステムの豊富なライブラリを活用できる点が強みです。Spring Bootは企業システムでの実績が豊富で、大規模サービスの運用に適しています。DDDとクリーンアーキテクチャを組み合わせることで、ビジネスロジックを明確に分離し、依存関係を適切に制御できます。これにより、10年後も保守可能なコードベースを構築できます。

---

## 3. 背景に記載がない前提

本検討では、以下の前提を置いています：

1. **チーム構成**: 現在のPHPエンジニアが新言語を学習する意欲と時間的余裕がある
2. **移行戦略**: ビッグバンリプレースではなく、段階的な移行（ストラングラーパターン）を採用可能
3. **インフラ**: クラウド環境（AWS/GCP等）での運用を想定
4. **データベース**: 既存のRDBMS（MySQL/PostgreSQL等）を継続利用
5. **開発期間**: 2〜3年程度の移行期間を確保可能
6. **予算**: 新技術習得のための教育投資が可能
7. **採用**: 新しい技術スタックでのエンジニア採用が視野に入っている

---

## 4. 検討の詳細

### 4.1 言語・技術スタックの比較検討

#### 候補1: PHP + Laravel

**メリット:**
- 既存チームのスキルセットを最大限活用可能
- 移行コストが最も低い
- Laravelは現代的な設計思想を取り入れている
- 豊富な日本語ドキュメントとコミュニティ

**デメリット:**
- PHPの型システムは他言語に比べて弱い
- 大規模開発での型安全性に限界がある
- 「PHPから脱却したい」という動機が満たされない

**評価:** 移行コストは低いが、根本的な保守性向上には限界がある

#### 候補2: Go

**メリット:**
- 高いパフォーマンスとメモリ効率
- シンプルな言語仕様で学習曲線が緩やか
- 静的型付けによる堅牢性
- コンパイル済みバイナリでデプロイが容易
- Googleによる強力なサポート

**デメリット:**
- ジェネリクスの導入が最近で、エコシステムがまだ成熟途上
- ORMや依存性注入の文化が薄い
- エンタープライズ向けフレームワークが少ない
- PHPエンジニアにとってパラダイムシフトが大きい

**評価:** パフォーマンス重視のマイクロサービスには最適だが、大規模モノリスの再構築には不向き

#### 候補3: Kotlin + Spring Boot（推奨）

**メリット:**
- 強力な型システムとNull安全性
- Javaとの100%互換性でJavaエコシステム全体を活用可能
- Spring Bootの豊富なエンタープライズ機能
- コルーチンによる非同期処理のサポート
- 表現力の高い文法で可読性が高い
- Android開発とのシナジー（将来的なモバイルアプリ開発を視野に）

**デメリット:**
- JVMの運用知見が必要
- 起動時間がやや遅い（GraalVM Native Imageで改善可能）
- PHPからの学習コストは中程度

**評価:** 型安全性、エコシステムの成熟度、保守性のバランスが最も良い

#### 候補4: TypeScript + NestJS

**メリット:**
- フロントエンドとバックエンドで言語統一可能
- JavaScriptエンジニアの採用プールが大きい
- NestJSはAngularライクな構造化されたアーキテクチャ
- 型安全性をTypeScriptで確保

**デメリット:**
- 実行時パフォーマンスはJVM/Goに劣る
- TypeScriptの型は実行時に消える（ランタイム型安全性なし）
- Node.jsの大規模運用は難易度が高い

**評価:** フルスタックJavaScriptを志向する場合は有力だが、バックエンド単独では他選択肢に劣る

### 4.2 開発手法・設計理論の検討

#### ドメイン駆動設計 (DDD)

**採用理由:**
- 10年の歴史で蓄積されたビジネスロジックを整理・可視化できる
- ユビキタス言語により、開発者とビジネスサイドの認識を統一
- 境界づけられたコンテキスト（Bounded Context）で責務を明確化
- 将来的なマイクロサービス分割の境界を見極められる

**実践のポイント:**
- 戦略的設計（コンテキストマップ）から着手
- 集約（Aggregate）の設計を慎重に行う
- リポジトリパターンでデータアクセスを抽象化

#### クリーンアーキテクチャ

**採用理由:**
- 依存関係の方向を内側（ドメイン）に向けることで、変更に強い構造を実現
- フレームワークやデータベースへの依存を外側に追いやる
- ユースケース層でビジネスロジックを明確に表現
- テスタビリティが大幅に向上

**レイヤー構成:**
```
┌─────────────────────────────────────────┐
│  Frameworks & Drivers (外部)            │
│  ┌─────────────────────────────────┐    │
│  │  Interface Adapters             │    │
│  │  ┌─────────────────────────┐    │    │
│  │  │  Use Cases              │    │    │
│  │  │  ┌─────────────────┐    │    │    │
│  │  │  │  Entities       │    │    │    │
│  │  │  │  (Domain)       │    │    │    │
│  │  │  └─────────────────┘    │    │    │
│  │  └─────────────────────────┘    │    │
│  └─────────────────────────────────┘    │
└─────────────────────────────────────────┘
```

#### その他検討した手法

**CQRS (Command Query Responsibility Segregation):**
- 読み取りと書き込みの分離により、それぞれを最適化可能
- 会員900万人規模では読み取り負荷が高いと想定され、有効
- 必要に応じて段階的に導入を検討

**イベント駆動アーキテクチャ:**
- サービス間の疎結合化に有効
- 将来的なマイクロサービス化への布石として検討
- Apache Kafka等のメッセージブローカーの運用知見が必要

### 4.3 移行戦略の提案

**ストラングラーパターンの採用を推奨:**

1. **Phase 1**: 新規機能をKotlin/Spring Bootで開発開始
2. **Phase 2**: APIゲートウェイを導入し、新旧システムを共存
3. **Phase 3**: 優先度の高いドメインから段階的に移行
4. **Phase 4**: 旧システムの段階的廃止

**リスク軽減策:**
- 最初は小規模な新機能で技術検証
- チーム内でKotlin/Spring Bootの勉強会を実施
- 外部のアーキテクトによるレビューを定期的に実施

---

## 5. 最終的な推奨構成

```
言語:           Kotlin
フレームワーク:  Spring Boot 3.x
ビルドツール:    Gradle (Kotlin DSL)
アーキテクチャ:  クリーンアーキテクチャ + DDD
テスト:         JUnit 5 + Kotest + MockK
API:            REST (将来的にGraphQL検討)
DB:             既存RDBMSを継続 + Spring Data JPA
```

この構成により、型安全性・保守性・パフォーマンスのバランスを取りながら、10年後も持続可能なシステムを構築できると考えます。
